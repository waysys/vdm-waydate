-- ----------------------------------------------------------------------------
--
-- Holidays - Specification for U.S. Federal holidays and Easter.
-- Author: William Shaffer (wshaffer@waysysweb.com)
-- Date: 09 Dec 2023
--
-- This module extends the Date module by providing a specification
-- of U.S. federal holidays and Easter.
--
-- Some of these holidays are positional, meaning that they occur on a 
-- specified day of the week in a month. The remaining holidays occur on 
-- specified dates. However, for this second category, if the date occurs 
-- on a Saturday, the holiday is observed on the preceding Friday. If the 
-- date occurs on a Sunday, the holiday is observed on the following Monday. 
-- Easter is not a federal holiday and is always observed on Sunday.
-- ----------------------------------------------------------------------------
module Holidays

imports
    from Date
        types 
            Month renamed Month;
            Day renamed Day;
            Year renamed Year
            Date renamed Date;

        functions
            create: Month * Day * Year -> Date;
            intToMonth: int -> Month;
            intToDay: int -> Day;
            yearToInt: Year -> nat1;
            increment: Date -> Date;
            decrement: Date -> Date;
            daysInMonth: Month * Year -> nat1;
            before: Date * Date -> bool;

        operations  
            addDay : Date * int ==> Date,

    from Week
        types
            DayOfWeek renamed DayOfWeek;

        values
            daysOfWeek;

        functions
            dayOfWeek: Date -> DayOfWeek; 

    exports
        types
            struct Holiday;

        functions
            -- holiday functions
            newYearsDay: Year -> Holiday;
            martinLutherKingBirthday: Year -> Holiday;
            washingtonsBirthday: Year -> Holiday;
             easter: Year -> Holiday;
            memorialDay: Year -> Holiday;
            juneteenth: Year -> Holiday;
            independenceDay: Year -> Holiday;
            laborDay: Year -> Holiday;
            columbusDay: Year -> Holiday;
            veteransDay: Year -> Holiday;
            thanksgiving: Year -> Holiday;
            christmas: Year -> Holiday;
            
            -- properties
            getName: Holiday -> seq of char;
            getActualDate: Holiday -> Date;
            getObservedDate: Holiday -> Date;
            getObservedDayOfWeek: Holiday -> DayOfWeek;

            -- support functions
            observedDate: Date -> Date;
            nthDayOfMonth: Month * DayOfWeek * nat1 * Year -> Date;
            lastWeekDayOfMonth: Month * Year * DayOfWeek -> Date;
            dayOfWeekAfter: Date * DayOfWeek -> Date;

definitions

-- ----------------------------------------------------------------------------
types
-- ----------------------------------------------------------------------------

-- Holiday provides the official name of the holiday, the actual date of the 
-- holiday, and the day the holiday is observed by the U.S. government.
Holiday ::
    name : seq of char
    actualDate : Date
    observedDate : Date
    observedDayOfWeek : DayOfWeek;

-- ----------------------------------------------------------------------------
values
-- ----------------------------------------------------------------------------

sunday : DayOfWeek = Week`daysOfWeek(1);
monday : DayOfWeek = Week`daysOfWeek(2);
thursday : DayOfWeek = Week`daysOfWeek(5);
saturday : DayOfWeek = Week`daysOfWeek(7);

january = Date`intToMonth(1);
february = Date`intToMonth(2);
may = Date`intToMonth(5);
june = Date`intToMonth(6);
july = Date`intToMonth(7);
september = Date`intToMonth(9);
october = Date`intToMonth(10);
november = Date`intToMonth(11);
december = Date`intToMonth(12)

-- ----------------------------------------------------------------------------
functions
-- ----------------------------------------------------------------------------

-- Holidays -------------------------------------------------------------------

-- New Yearâ€™s Day: fixed holiday.  If it falls on a weekend, the observed day
-- is on Friday or Monday.
newYearsDay: Year -> Holiday
newYearsDay(year) ==
    let
        name = "New Year's Day",
        day : Day = Date`intToDay(1)
    in
        createFixedHoliday(name, january, day, year)
pre Date`yearToInt(year) >= 1900;

-- Birthday of Martin Luther King, Jr.: floating holiday -- third Monday in
-- January. 
martinLutherKingBirthday: Year -> Holiday 
martinLutherKingBirthday(year) ==
    let
        name = "Birthday of Martin Luther King, Jr."
    in
        createFloatingHoliday(name, january, monday, 3, year)
pre Date`yearToInt(year) >= 1986;   

-- Washington's Birthday: floating holiday -- third Monday in
-- February.
washingtonsBirthday: Year -> Holiday
washingtonsBirthday(year) ==
   let
        name = "Washington's Birthday"
    in
         createFloatingHoliday(name, february, monday, 3, year)
pre Date`yearToInt(year) >= 1968;

 -- Memorial Day: floating holiday -- last Monday in May.
 memorialDay: Year -> Holiday
 memorialDay(year) ==
    let 
        name = "Memorial Day",
        actualDate = lastWeekDayOfMonth(may , year, monday),
        observeDate = actualDate,
        observedDayOfWeek = Week`dayOfWeek(observeDate)
    in
        mk_Holiday(name, actualDate, observeDate, observedDayOfWeek)
pre Date`yearToInt(year) >= 1971;

-- Juneteenth National Independence Day: fixed holiday - June 19
juneteenth: Year -> Holiday
juneteenth(year) ==
   let 
        name = "Juneteenth National Independence Day",
        day : Day = Date`intToDay(19)
    in
        createFixedHoliday(name, june, day, year)
pre Date`yearToInt(year) >= 2021;

-- Independence Day: fixed holiday - July 4
independenceDay: Year -> Holiday
independenceDay(year) ==
    let 
        name = "Independence Day",
        day : Day = Date`intToDay(4)
    in 
        createFixedHoliday(name, july, day, year)
pre Date`yearToInt(year) >= 1870;

-- Labor Day: floating holiday - first Monday in September
laborDay: Year -> Holiday
laborDay(year)  ==
    let 
        name = "Labor Day"
    in
        createFloatingHoliday(name, september, monday, 1, year)
pre Date`yearToInt(year) >= 1894;

-- Columbus Day: floating holiday - second Monday in October
columbusDay: Year -> Holiday 
columbusDay(year) == 
    let 
        name = "Columbus Day"
    in
        createFloatingHoliday(name, october, monday, 2, year)
pre Date`yearToInt(year) >= 1971;   

-- Veteran's Day: fixed holiday - November 11
veteransDay: Year -> Holiday
veteransDay(year) ==
    let 
        name = "Veteran's Day",
        day : Day = Date`intToDay(11)
    in 
        createFixedHoliday(name, november, day, year)
pre Date`yearToInt(year) >= 1954; 

-- Thanksgiving Day: floating holiday - Fourth Thursday in November
thanksgiving: Year -> Holiday
thanksgiving(year) ==
    let 
        name = "Thanksgiving Day"
    in 
        createFloatingHoliday(name, november, thursday, 4, year)
pre Date`yearToInt(year) >= 1942; 

-- Christmas Day: fixed holiday - December 25
christmas: Year -> Holiday
christmas(year) == 
    let 
        name = "Christmas Day",
        day : Day = Date`intToDay(25)
    in 
        createFixedHoliday(name, december, day, year)
 pre Date`yearToInt(year) >= 1900;     

 -- Easter --------------------------------------------------------------------

 -- easter: Sunday after pashcal moon.  Algorithm based on Reingold and 
 -- Dershowitz, Calendrical Calculation: The Millennium Edition.
 -- Easter can never occur before March 22 or later than April 25
 easter: Year -> Holiday
 easter(year) ==
    let 
        yr = Date`yearToInt(year),
        april = Date`intToMonth(4),
        nineteen = Date`intToDay(19),
        century = (yr div 100) + 1,
        shiftedEpact = (14 + (11 * (yr mod 19)) - ((3 * century) div 4) + ((5 + 8 * century) div 25)) mod 30,
        adjustedEpact = if shiftedEpact = 0 or ( (shiftedEpact = 1) and (10 < (yr mod 19)))
            then shiftedEpact + 1
            else shiftedEpact,
        paschalMoon = Date`addDay(Date`create(april, nineteen, year), -adjustedEpact),
        easterSunday = dayOfWeekAfter(paschalMoon, sunday) 
    in  
        mk_Holiday("Easter", easterSunday, easterSunday, sunday)
 pre Date`yearToInt(year) >= 1900;

-- Properties -----------------------------------------------------------------

-- getName returns the name of the holiday
getName: Holiday -> seq of char
getName(holiday) ==
    holiday.name;

-- getActualDate returns the actual date of the holiday.
getActualDate: Holiday -> Date
getActualDate(holiday) ==
    holiday.actualDate;

-- getObservedDate returns the observed date of the holiday.
getObservedDate: Holiday -> Date
getObservedDate(holiday) ==
    holiday.observedDate;

-- getObservedDayOfWeek returns the day of week of the observed date.date 
getObservedDayOfWeek: Holiday -> DayOfWeek
getObservedDayOfWeek(holiday) ==
    holiday.observedDayOfWeek;

-- Supporting functions -------------------------------------------------------

-- createFixedHoliday creates a Holiday structure for the specified fixed 
-- US federal holiday.
createFixedHoliday: seq of char * Month * Day * Year  -> Holiday
createFixedHoliday(name, month, day, year) ==
    let 
        actualDate = Date`create(month, day, year),
        observeDate = observedDate(actualDate),
        observedDayOfWeek = Week`dayOfWeek(observeDate)
    in 
        mk_Holiday(name, actualDate, observeDate, observedDayOfWeek)
pre Date`yearToInt(year) >= 1900;

-- createFloatingHoliday creates a Holiday structure for a floating 
-- US federal holiday.  Cannot be used for Memorial Day.
createFloatingHoliday: seq of char * Month * DayOfWeek * nat1 * Year  -> Holiday
createFloatingHoliday(name, month, dayOfWeek, position, year) ==
   let 
        actualDate = nthDayOfMonth(month , dayOfWeek, position, year),
        observeDate = actualDate,
        observedDayOfWeek = Week`dayOfWeek(observeDate)
    in
        mk_Holiday(name, actualDate, observeDate, observedDayOfWeek)
pre Date`yearToInt(year) >= 1900;     

-- observedDate implements the U.S federal rule: If a holiday falls on a Saturday, 
-- for most Federal employees, the preceding Friday will be treated as a holiday 
-- for pay and leave purposes. (See 5 U.S.C. 6103(b).) If a holiday falls on a 
-- Sunday, for most Federal employees, the following Monday will be treated as a 
-- holiday for pay and leave purposes. 
observedDate: Date -> Date
observedDate(date) ==
    cases Week`dayOfWeek(date):
        (saturday) -> Date`decrement(date),
        (sunday) -> Date`increment(date),
        others -> date
    end;

-- nthDayOfMonth calculates the positional date based on the month, day of the week,
-- the position in the month (first, second, third, etc.), and year. 
nthDayOfMonth: Month * DayOfWeek * nat1 * Year -> Date
nthDayOfMonth(month, dayOfWeek, position, year) ==
    let
        day = Date`intToDay(1),
        date = Date`create(month, day, year)
    in 
        computeNthDayOfMonth(month, dayOfWeek, position, date)
pre position >= 1 and position <= 4;

-- computeNthDayOfMOnth performs the actual computation of the nthDayOfThe Month. 
computeNthDayOfMonth: Month * DayOfWeek * nat1 * Date -> Date
computeNthDayOfMonth(month, dayOfWeek, position, date) ==
    if position = 1 and Week`dayOfWeek(date) = dayOfWeek
        then date
    elseif position > 1 and Week`dayOfWeek(date) = dayOfWeek 
        then computeNthDayOfMonth(month, dayOfWeek, position - 1, Date`addDay(date, 7))
    else computeNthDayOfMonth(month, dayOfWeek, position, Date`increment(date))
pre position >= 1 and position <= 4
measure is not yet specified;

-- lastWeekDayOfMonth calculates the last day of the week in a month and year. 
lastWeekDayOfMonth: Month * Year * DayOfWeek -> Date
lastWeekDayOfMonth(month, year, dayOfWeek) ==
    let
        daysInMonth = Date`intToDay(Date`daysInMonth(month, year)),
        lastDateOfMonth = Date`create(month, daysInMonth, year)
    in
        computeLastWeekDayOfMonth(month, year, dayOfWeek, lastDateOfMonth);

-- computeLastWeekDayOfMonth calculates the date of the last day of the week. 
computeLastWeekDayOfMonth: Month * Year * DayOfWeek * Date -> Date
computeLastWeekDayOfMonth(month, year, dayOfWeek, date) == 
    if Week`dayOfWeek(date) = dayOfWeek then date
    else computeLastWeekDayOfMonth(month, year, dayOfWeek, Date`decrement(date))
measure is not yet specified;

-- dayOfWeekAfter determines the date of the day with a day of the week
-- equal to the specified day of the week and after the specified  
-- base date. 
dayOfWeekAfter: Date * DayOfWeek -> Date 
dayOfWeekAfter(baseDate, dayOfWeek) ==
    dayOfWeekAfterBaseDate(baseDate, dayOfWeek, baseDate);

-- dayOfWeekAfterBaseDate calculates the date of the day with a day of 
-- the week equal to the specified day of the week and after specified 
-- base date. 
dayOfWeekAfterBaseDate: Date * DayOfWeek * Date -> Date 
dayOfWeekAfterBaseDate(date, dayOfWeek, baseDate) ==
    if date = baseDate then dayOfWeekAfterBaseDate(Date`increment(date), dayOfWeek, baseDate)
    elseif Week`dayOfWeek(date) = dayOfWeek then date 
    else dayOfWeekAfterBaseDate(Date`increment(date), dayOfWeek, baseDate)
pre not Date`before(date, baseDate)
measure is not yet specified;
-- Postcondition:
--    result > baseDate and Date`dayOfWeek(result) = dayOfWeek and
--    not exist date : Date & date <> result and date <> baseDate and 
--       DateRange`inRange(DateRange`create(baseDate, result), date)

end Holidays