-- ----------------------------------------------------------------------------
--
-- WayDate - date manipulation specification.
-- Author: William Shaffer (wshaffer@waysysweb.com)
-- Date: 17 Nov 2023
--
-- This module provides a specification for date creation and manipulation.
-- The definitions can be used in proofs of date codes.
-- ----------------------------------------------------------------------------
module Date

exports types Month; Day; Year; DayOfYear; struct Date; Order; 

        functions   -- Constructors
                    create: Month * Day * Year -> Date;
                    createFromDayOfYear: DayOfYear * Year -> Date;

                    -- Properties
                    getDay: Date -> Day;
                    getMonth: Date -> Month;
                    getYear: Date -> Year;

                    -- Information Functions
                    isLeapYear:  Year -> bool;
                    daysInYear: Year -> nat1;
                    dayOfYear: Date -> DayOfYear;
                    daysInMonth: Month * Year -> nat1;

                    -- Comparisons
                    compare: Date * Date -> Order;
                    after: Date * Date -> bool;
                    before: Date * Date -> bool;
                    maxDate: Date * Date -> Date;
                    minDate: Date * Date -> Date;

                    -- Conversions
                    intToDayOfYear: int -> DayOfYear;
                    intToYear: int -> Year;
                    dayOfYearToNat: DayOfYear -> nat1;
                    yearToNat: Year -> nat1;
                    intToMonth: int -> Month;
                    monthToInt: Month -> int;
                    intToDay: int -> Day;
                    dayToInt: Day -> int;

                    -- Calculations
                    increment: Date -> Date;
                    decrement: Date -> Date

        values      MaxYear : Year; MinYear: Year; MaxDate : Date; MinDate: Date;

        operations  add : Date * int ==> Date;
                    difference : Date * Date ==> int;

        -- Relational operators >, >=, =, <=, < can also be used


definitions

-- ----------------------------------------------------------------------------
types
-- ----------------------------------------------------------------------------

Month = nat1
inv month == month >= 1 and month <= 12;

Day = nat1
inv day == day >= 1 and day <= 31;

Year = nat1
inv year == year >= 1601 and year <= 3999;

DayOfYear = nat1
inv dayYear == dayYear >= 1 and dayYear <= 366;

Date :: month : Month
        day   : Day
        year  : Year
inv mk_Date(month, day, year) == isDay(month, day, year)
ord mk_Date(month1, day1, year1) < mk_Date(month2, day2, year2) ==
    year1 < year2 or
    year1 = year2 and month1 < month2 or
    year1 = year2 and month1 = month2 and day1 < day2;

DaysPerMonth = map  Month to nat;

Order = <Before> | <Equal> | <After>;

-- ----------------------------------------------------------------------------
values
-- ----------------------------------------------------------------------------

MaxYear : Year = 3999;
MinYear : Year = 1601;

daysPerMonth : DaysPerMonth = {
    1  |-> 31, 
    2  |-> 28,
    3  |-> 31,
    4  |-> 30,
    5  |-> 31,
    6  |-> 30,
    7  |-> 31,
    8  |-> 31,
    9  |-> 30,
    10 |-> 31,
    11 |-> 30,
    12 |-> 31
};

MaxDate = create(12, 31, MaxYear);
MinDate = create(1, 1, MinYear);

-- ----------------------------------------------------------------------------
functions
-- ----------------------------------------------------------------------------

-- Validation Functions

-- isDay returns true if day is a valid day given the specified month and year.
isDay: Month * Day * Year -> bool
isDay(month, day, year) ==
    if day > daysInMonth(month, year) then false
    else true;

-- isDay returns true if dayOfYear is a valid day of year given the specified
-- year.
isDayOfYear: DayOfYear * Year -> bool
isDayOfYear(dayYear, year) ==
    if dayYear < 1 then false
    else if dayYear > daysInYear(year) then false
    else true;

-- Information Functions

-- daysInMonth return the number of days in the specified month and year.
daysInMonth: Month * Year -> nat1
daysInMonth(month, year) ==
    if isLeapYear(year) and (month = 2) then daysPerMonth(2) + 1
    else daysPerMonth(month);

-- isLeapYear returns true if the year is a leap year.
isLeapYear: Year -> bool
isLeapYear(year) ==
    if year mod 400 = 0 then true
    elseif year mod 100 = 0 then false 
    elseif year mod 4 = 0 then true 
    else false;

-- daysInYear returns the number of days in the specified year.
daysInYear: Year -> nat1
daysInYear(year) ==
    if isLeapYear(year) then 366
    else 365;

-- Properties

getMonth: Date -> Month
getMonth(date) == 
    date.month;

getDay: Date -> Day
getDay(date) ==
    date.day;

getYear: Date -> Year
getYear(date) ==
    date.year;

-- Constructors

-- create constructs a date given the specified month, day, and year.  The day
-- must be a valid day given the month and year.
create: Month * Day * Year -> Date
create(month, day, year) ==
    mk_Date(month, day, year)
pre isDay(month, day, year);

-- createFromDayOfYear constructs a date with a day of year equal to the specified
-- day of the year.
createFromDayOfYear: DayOfYear * Year -> Date
createFromDayOfYear(dayYear, year) ==
    add(create(1, 1, year), dayYear - 1)
pre isDayOfYear(dayYear, year);

-- Calulations

-- increment adds a day to a date and returns a new date with the result. The MaxDate cannot
-- be incremented.
increment: Date -> Date
increment(date) == 
    if date.month = 12 and date.day = 31 then create(1, 1, date.year + 1)
    elseif date.day = daysInMonth(date.month, date.year) then create(date.month + 1, 1, date.year)
    else create(date.month, date.day + 1, date.year)
pre date <> MaxDate;

-- decrement subtracts a day to a date and returns a new date with the result.  The MinDate
-- cannot be decremented.
decrement: Date -> Date
decrement(date) ==
    if date.month = 1 and date.day = 1 then create(12, 31, date.year - 1)
    elseif date.day = 1 then create(date.month - 1, daysInMonth(date.month - 1, date.year), date.year)
    else create(date.month, date.day - 1, date.year)
pre date <> MinDate;

-- dayOfYear comoputes the day of the year for the specified date.  1-Jan-YYYY is day 1.
dayOfYear: Date -> DayOfYear
dayOfYear(date) ==
    let
        firstOfYear = create(1, 1, date.year)
    in
        difference(date, firstOfYear) + 1;

-- Comparison

-- compare compares two dates and returns an order type.  If date1 is before date two, compare returns <Before>.
-- If date1 is after date2, compare returns <After>.  If date1 = date2, compare returns <Equal>.
compare: Date * Date -> Order
compare(date1, date2) ==
    if date1.year < date2.year then <Before>
    elseif date1.year = date2.year and date1.month < date2.month then <Before>
    elseif date1.year = date2.year and date1.month = date2.month and date1.day < date2.day then <Before>
    elseif date1.year = date2.year and date1.month = date2.month and date1.day = date2.day then <Equal>
    else <After>;

-- before returns true if date1 is before date2.  Otherwise it returns false.
before: Date * Date -> bool
before(date1, date2) ==
    compare(date1, date2) = <Before>;

-- after returns true if date1 is after date2.  Otherwise it returns false.
after: Date * Date -> bool
after(date1, date2) ==
    compare(date1, date2) = <After>;

-- maxDate returns the later of two dates
maxDate: Date * Date -> Date
maxDate(date1, date2) ==
    if after(date1, date2) then date1
    else date2;

-- minDate returns the earlier of two dates
minDate: Date * Date -> Date
minDate(date1, date2) ==
    if before(date1, date2) then date1
    else date2;

-- Conversions
intToDayOfYear: int -> DayOfYear
intToDayOfYear(value) ==
    value
pre value >= 1 and value <= 366;

dayOfYearToNat: DayOfYear -> nat1
dayOfYearToNat(dayYear) ==
    dayYear;

intToYear: int -> Year
intToYear(value) ==
    value
pre value >= MinYear and value <= MaxYear;

yearToNat: Year -> nat1
yearToNat(year) ==
    year;

intToMonth: int -> Month
intToMonth(value) ==
    value
pre value >= 1 and value <= 12;

monthToInt: Month -> int
monthToInt(month) ==
    month;

intToDay: int -> Day
intToDay(value) ==
    value
pre value >= 1 and value <= 31;

dayToInt: Day -> int
dayToInt(day) ==
    day

-- ----------------------------------------------------------------------------
operations
-- ----------------------------------------------------------------------------

-- add adds a number of days equal to count to a date and returns the result.  Count can be negative, in which
-- case, a number of days equal to count is subtracted from the date.  A positive count cannot be added to
-- MaxDate.  A negative count cannot be subracted from MinDate.
pure add: Date * int ==> Date
add(date, count) ==
    ( dcl result : Date := date,
          index : int := count;
    while index > 0 do (
        result := increment(result);
        index := index - 1;
    );
    while index < 0 do (
        result := decrement(result);
        index := index + 1
    );
    return result
    );

-- difference returns the number of days between date1 and date2.  If date1 is before date2, the number
-- of days is a negative number.  If date1 is after date2, the number is positive.
pure difference: Date * Date ==> int 
difference(date1, date2) ==
   (dcl diff : int := 0,
        dt1 : Date := date1,
        dt2 : Date := date2;
    while compare(dt1, dt2) = <Before> do (
        diff := diff - 1;
        dt1 := increment(dt1)
    );
    while compare(dt1, dt2) = <After> do (
        diff := diff + 1;
        dt1 := decrement(dt1)
    );
    return diff
   )


end Date